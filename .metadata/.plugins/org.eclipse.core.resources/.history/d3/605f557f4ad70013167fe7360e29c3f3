import java.util.ArrayDeque;
import java.util.Deque;


public class BipartiteUndirected {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}
	
	private static boolean isBipartite;   // is the graph bipartite?
    private static boolean[] color;       // color[v] gives vertices on one side of bipartition
    private static boolean[] marked;      // marked[v] = true if v has been visited in DFS
    private static int[] edgeTo;          // edgeTo[v] = last edge on path to v
    private static Deque<Integer> cycle;  // odd-length cycle
	public static void dfs(Graph G, int v) { 
        marked[v] = true;
        for (int w : G.adj(v)) {

            // short circuit if odd-length cycle found
            if (cycle != null) return;

            // found uncolored vertex, so recur
            if (!marked[w]) {
                edgeTo[w] = v;
                color[w] = !color[v];
                dfs(G, w);
            } 

            // if v-w create an odd-length cycle, find it
            else if (color[w] == color[v]) {
                isBipartite = false;
                cycle = new ArrayDeque<Integer>();
                cycle.offer(w);  // don't need this unless you want to include start vertex twice
                for (int x = v; x != w; x = edgeTo[x]) {
                    cycle.offer(x);
                }
                cycle.offer(w);
            }
        }
    }

}
