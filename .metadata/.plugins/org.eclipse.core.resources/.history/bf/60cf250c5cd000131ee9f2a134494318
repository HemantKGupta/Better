
public class BuildFBTPrePost {

	public static void main(String[] args) {
		int[] pre = {1, 2, 4, 8, 9, 5, 3, 6, 7};
		int[] post = {8, 9, 4, 5, 2, 6, 7, 3, 1};
		BNode root = null;
		root = constructTree( pre, post);
		printInorder(root);
		//System.out.println(root);
		
	}

	public static int preIndex;
	// A recursive function to construct Full from pre[] and post[]. 
	// preIndex is used to keep track of index in pre[].
	// l is low index and h is high index for the current subarray in post[]
	public static BNode constructTreeUtil (int pre[], int post[],
	                                int l, int h, int size)
	{
	    // Base case
	    if (preIndex >= size || l > h)
	        return null;
	 
	    int rootdata = pre[preIndex];
	    BNode root = new BNode (rootdata  );
	    ++preIndex;
	 
	   // System.out.println(preIndex);
	    
	    if (l == h)
	        return root;
	 
	    // Search the next element of pre[] in post[]
	    int i;
	    for (i = l; i <= h; ++i)
	        if (rootdata == post[i])
	            break;
	 
	    // Use the index of element found in postorder to divide postorder array in
	    // two parts. Left subtree and right subtree
	    if (i <= h)
	    {
	        root.left = constructTreeUtil (pre, post, l, i, size);
	        root.right = constructTreeUtil (pre, post,  i + 1, h, size);
	    }
	 
	    return root;
	}
	 
	// The main function to construct Full Binary Tree from given preorder and 
	// postorder traversals. This function mainly uses constructTreeUtil()
	public static BNode constructTree (int pre[], int post[])
	{
	    int size = pre.length;
	    return constructTreeUtil (pre, post, 0, size - 1, size);
	}
	
	public static void printInorder(BNode node) {
		if (node == null)
			return;

		printInorder(node.left);
		System.out.format("%d ", node.data);
		printInorder(node.right);
	}
}
