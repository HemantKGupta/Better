public class BSTSimpleOperations {

	public static void main(String[] args) {
		BNode root = new BNode(5);
		root.left = new BNode(3);
		root.right = new BNode(9);
		root.left.left = new BNode(1);
		root.left.right = new BNode(4);
		root.right.left = new BNode(6);
		
		System.out.println("The tree is BST: "+ isBST(root));
		System.out.println("The minimum value in BST is: "+ minvalue(root));
		System.out.println("The maximum value in BST is: "+ maxvalue(root));
	}

	/*
	 * Returns true if the given tree is a binary search tree (efficient
	 * version).
	 */
	public static boolean isBST(BNode node) {
		return (isBSTUtil(node, Integer.MIN_VALUE, Integer.MAX_VALUE));
	}

	/*
	 * Returns true if the given tree is a BST and its values are >= min and <=
	 * max.
	 */
	public static boolean isBSTUtil(BNode node, int min, int max) {

		/* an empty tree is BST */
		if (node == null)
			return true;

		/* false if this node violates the min/max constraint */
		if (node.data < min || node.data > max)
			return false;

		/*
		 * otherwise check the subtrees recursively, tightening the min or max
		 * constraint
		 */
		return isBSTUtil(node.left, min, node.data - 1)
				&& isBSTUtil(node.right, node.data + 1, max); // Allow only distinct values
	}
	/* 
	 Given a non-empty binary search tree, 
	 return the minimum data value found in that tree. 
	 Note that the entire tree does not need to be searched. 
	*/ 	
	public static int minvalue(BNode node){
		BNode current = node;
		while (current.left != null){
			current = current.left;
		}
		return current.data;
	}
	/* 
	 Given a non-empty binary search tree, 
	 return the maximum data value found in that tree. 
	 Note that the entire tree does not need to be searched. 
	*/ 	
	public static int maxvalue(BNode node){
		BNode current = node;
		while (current.right != null){
			current = current.right;
		}
		return current.data;
	}

}
