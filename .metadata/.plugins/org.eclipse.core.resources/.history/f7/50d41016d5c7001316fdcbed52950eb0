import java.util.Deque;
import java.util.List;


public class MergeOverlappingIntervals {

	public static void main(String[] args) {

	}
	
	// Compares two intervals according to their staring time.
	// This is needed for sorting the intervals using library
	// function std::sort(). See http://goo.gl/iGspV
	public boolean compareTo(Interval i1, Interval i2)
	{  return (i1.start < i2.start)? true: false; }
	 
	// The main function that takes a set of intervals, merges
	// overlapping intervals and prints the result
	public static void mergeIntervals(List<Interval> intervals)
	{
	    // backtracking.Test if the given set has at least one interval
	    if (intervals.size() <= 0)
	        return;
	 
	    // Create an empty stack of intervals
	    Deque<Interval> stack;
	 
	    // sort the intervals based on start time
	    Collection.sort(intervals,);
	 
	    // push the first interval to stack
	    stack.push(intervals[0]);
	 
	    // Start from the next interval and merge if necessary
	    for (int i = 1 ; i < intervals.size(); i++)
	    {
	        // get interval from stack top
	        Interval top = stack.top();
	 
	        // if current interval is not overlapping with stack top,
	        // push it to the stack
	        if (top.end < intervals[i].start)
	        {
	            stack.push( intervals[i] );
	        }
	        // Otherwise update the ending time of top if ending of current 
	        // interval is more
	        else if (top.end < intervals[i].end)
	        {
	            top.end = intervals[i].end;
	            stack.pop();
	            stack.push(top);
	        }
	    }
	 
	    // Print contents of stack
	    cout << "\n The Merged Intervals are: ";
	    while (!stack.empty())
	    {
	        Interval t = stack.top();
	        cout << "[" << t.start << "," << t.end << "]" << " ";
	        stack.pop();
	    }
	 
	    return;
	}

}

class Interval implements Comparable<Interval>
{
    int start;
    int end;
	@Override
	public int compareTo(Interval o) {
		return this.start - o.start;
	}
    
}
