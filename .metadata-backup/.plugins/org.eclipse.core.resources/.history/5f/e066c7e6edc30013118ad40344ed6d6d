public class MergeTwoBST {

	public static void main(String[] args) {
		// TODO Auto-generated method stub

	}

	public static BNode mergeTrees(BNode root1, BNode root2, int m, int n) {
		int[] arr1 = new int[m];
		int i = 0;
		storeInorder(root1, arr1, i);

		int[] arr2 = new int[n];
		int j = 0;
		storeInorder(root2, arr2, j);

		// Merge the two sorted array into one
		int[] mergedArr = merge(arr1, arr2, m, n);

		// Construct a tree from the merged array and return root of the tree
		return sortedArrayToBST(mergedArr, 0, m + n - 1);
	}

	public static BNode sortedArrayToBST(int arr[], int start, int end) {
		if (start > end)
			return null;
		int mid = (start + end) / 2;
		BNode root = new BNode(arr[mid]);
		root.left = sortedArrayToBST(arr, start, mid - 1);
		root.right = sortedArrayToBST(arr, mid + 1, end);
		return root;
	}

	// A utility unction to merge two sorted arrays into one
	public static int[] merge(int arr1[], int arr2[], int m, int n) {
		// mergedArr[] is going to contain result
		int[] mergedArr = new int[m + n];
		int i = 0, j = 0, k = 0;

		// Traverse through both arrays
		while (i < m && j < n) {
			// Pick the smaler element and put it in mergedArr
			if (arr1[i] < arr2[j]) {
				mergedArr[k] = arr1[i];
				i++;
			} else {
				mergedArr[k] = arr2[j];
				j++;
			}
			k++;
		}

		// If there are more elements in first array
		while (i < m) {
			mergedArr[k] = arr1[i];
			i++;
			k++;
		}

		// If there are more elements in second array
		while (j < n) {
			mergedArr[k] = arr2[j];
			j++;
			k++;
		}

		return mergedArr;
	}

	public static void printInorder(BNode node) {
		if (node == null)
			return;

		printInorder(node.left);
		System.out.format("%d ", node.data);
		printInorder(node.right);
	}

}
